# transfer ether

在Solidity中，"address.transfer(amount)"、"address.send(amount)"和"address.call.value(amount)()"是三种不同的转账方法。

## 1. address.transfer(amount)

### 使用场景: 

接受地址是EOA, 无需对转账错误进行处理

### 描述

这是最常用的一种转账方法。它用于将指定数量的以太币（单位为Wei）从合约地址转账到目标地址。`如果转账失败，则会抛出异常`，并回滚所有的状态变化。同时，该方法会自动向目标地址发送2300个gas，无法调整gas数量。

## 2. address.send(amount)

### 使用场景: 
接受地址是EOA, 需要对转账错误进行处理

### 描述
这是另一种转账方法，与transfer方法类似。它也是将指定数量的以太币从合约地址转账到目标地址。与transfer方法不同的是，如果转账失败，它不会抛出异常，`而是返回一个布尔值false`。这个方法同样会发送2300个gas。

## 3. address.call.value(amount)()

### 使用场景: 

如果接受地址是合约, 并且对方合约receive函数里面有比较复杂的操作

### 描述
这是一种更底层的转账方法，可以实现更多复杂的操作。它通过使用call函数来调用目标地址的代码，并传递一个指定数量的以太币作为value。这个方法的返回值是一个布尔值，表示调用是否成功。通过这种方法，可以实现更灵活的转账操作，并可以自定义gas的数量。call的本意是发动函数调用, 当然也可以用来转账, 但是一般没有人会这么写, 因为这样代码编译之后size会变大. 还有一个最大不同, call合约发起转账的时候, `会把剩余的所有gas都发送过去`

## 总结: 

而上面两个合约是发送2300个基础gas, 对面合约收到转账之后, 啥也干不了.如果我们想安全的调用,那么应该使用send, 然后取返回值对面合约是不是想干点坏事, 结果gas不够报错了. 那么我们调用payable的时候应该使用address.call.value
