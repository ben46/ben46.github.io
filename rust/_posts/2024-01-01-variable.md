# q

1. Rust 为什么选择了手动设定变量的可变性？
2. Rust 中如何声明不可变变量？
3. 在 Rust 中，如何声明可变变量？
4. 为什么在 Rust 中要引入“所有权”这个新的概念？
5. 在 Rust 中，如何忽略未使用的变量？
6. 为什么在 Rust 中声明一个不会被使用的变量是有用的？
7. Rust 中的变量绑定是什么意思？
8. Rust 中的变量解构是如何实现的？
9. 在 Rust 中，如何声明常量？
10. 常量和变量之间有哪些差异？
11. Rust 中的变量遮蔽是什么意思？
12. 在 Rust 中，如何避免变量遮蔽导致的类型不匹配错误？
13. Rust 中如何声明一个包含多个元素的元组？
14. Rust 中如何使用模式匹配来解构变量？
15. 在 Rust 中，如何声明一个结构体并进行解构赋值？
16. Rust 中如何声明一个切片并进行解构赋值？
17. Rust 中如何声明一个常量并指定类型？
18. Rust 中如何声明一个全局作用域内的常量？
19. Rust 中如何声明一个变量并在后续代码中遮蔽之前的同名变量？
20. Rust 中如何使用 `_` 作为变量名的开头来忽略未使用的变量？

# q & a

### 1. Rust 为什么选择了手动设定变量的可变性？

既能保证代码的安全性，又能提升运行性能。通过手动设定变量的可变性，Rust能够避免一些多余的运行时检查，同时也让代码更加清晰和易于理解。

### 2. Rust 中如何声明不可变变量？

```rust
let x = 5;
```

### 3. 在 Rust 中，如何声明可变变量？

```rust
let mut x = 5;
```

### 4. 为什么在 Rust 中要引入“所有权”这个新的概念？

1. 保证任何时刻只有一个所有者可以访问读取和修改, 避免了(内存泄露,空指针,数据竞争)
2. 提高了性能, 减少内存开销

### 5. 在 Rust 中，如何忽略未使用的变量？

加下划线

### 7. Rust 中的变量绑定是什么意思？

通过变量绑定，我们可以将一个值的所有权转移给一个变量，使得该变量成为这个值的所有者

### 8. Rust 中的变量解构是如何实现的？

```rust
let (x, mut y):(bool, bool) = (true, false);
```

### 9. 在 Rust 中，如何声明常量？
```rust
const MAX_POINT: u32 = 10;
```

### 10. 常量和变量之间有哪些差异？

1. 常量不可变
2. 作用域和生命周期
3. 存储位置不一样, 常量会在编译的时候直接放在可执行文件里面

### 11. Rust 中的变量遮蔽是什么意思？

新声明的变量会覆盖之前同名变量的绑定，而不是修改之前变量的值。

### 12. 在 Rust 中，如何避免变量遮蔽导致的类型不匹配错误？

显式指定变量的类型

### 13. Rust 中如何声明一个包含多个元素的元组？

```rust
let my_tuple: (i32, f64, bool) = (10, 3.14, true);
```

### 14. Rust 中如何使用模式匹配来解构变量？
```rust
let my_tuple: (i32, f64, bool) = (10, 3.14, true);

// 使用模式匹配解构元组
let (x, y, z) = my_tuple;
```

15. 在 Rust 中，如何声明一个结构体并进行解构赋值？

```rust
// 定义一个结构体
struct Person {
    name: String,
    age: u32,
}

fn decodePerson(person: Person) -> (String, u32){
    let Person {name, age} = person;
    return (name, age)
}
```









