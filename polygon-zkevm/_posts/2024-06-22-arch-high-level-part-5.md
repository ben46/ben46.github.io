---
title: 6-Bridging
---
# Bridging

![fdsf](https://docs.polygon.technology/img/cdk/high-level-architecture/bridging-class-diagram.png)

这个统一桥梁通过调用PolygonZkEVMBridgeV2.sol合约的桥接和claim功能，在不同网络（L1、L2）之间传输资产和消息。合约部署在可升级代理地址上，实际操作通过代理进行。在L1部署了这个合约，每个L2网络也都有一个。它与特定于L1或L2的退出根管理合约密切交互。

# Bridge and claim

The main functions of the bridge are:

 - bridgeAsset(...)
- bridgeMessage(...)
 - claimAsset(...)
 - claimMessage(...)

### L1 to L2¶


要把资产从 L1 转移到 L2，发送者先把代币转到桥里，把资产锁定在起始网络 (L1)。


执行claimAsset时，桥接智能合约在目标网络（L2）上铸造原始资产的封装代币。封装代币是一个通用的ERC20代币。

一旦铸造完成，接收方可以在目标网络（L2）上领取这个代币。


### L2 to L1

要从 L2 网络发送资产到 L1，首先在 L2 网络上销毁包装代币。

执行 claimAsset 时，桥接智能合约会在源网络（L1）上解锁原始资产，准备领取。

## Transaction flows in depth
### L1 to L2
如果在L1上调用bridgeAsset或bridgeMessage通过了验证

**这里的验证**包括支付eth的amount和传入amount参数是否一致

bridge合约会把一个`exit leaf`添加到`L1退出树`，并计算新的L1退出根, 并且调用`L1全局退出根管理器`

`L1全局退出根管理器`会把新的`L1退出根`添加到`全局退出树`，并计算`全局退出根`

**至此, 第一步结束.**

`排序器`会从`L1全局退出根管理器`获取最新的全局退出根。

在交易批次开始时，`排序器`会把全局退出根*存储*在L2全局退出根管理智能合约的特殊存储槽中，允许L2用户访问它。

调用claimAsset或claimMessage时，需要提供一个*默克尔证明*来*验证*全局退出根中的正确*退出叶子*。

桥合约会根据全局退出根*验证*调用者的默克尔证明。如果证明有效，桥接过程成功；否则，交易失败。

### L2 to L1
如果在 L2 上调用 bridgeAsset 或 bridgeMessage 通过验证，桥接合约会把一个退出叶子加到 L2 退出树，并计算新的 L2 退出根。

L2 `全局退出根管理器`会把新的 L2 退出根加到全局退出树，并计算全局退出根。此时，调用者的桥接交易被包括在由`排序器`选择和排序的一批批次中。

`聚合器`会生成一个 `zk 证明`，证明包含交易的序列批次在执行时的计算完整性。

为了验证，`聚合器`会把 `zk 证明`和所有相关批次信息（这些信息导致了新的 L2 退出根的计算）发送给共识合约。

共识合约使用 verifyBatches 函数验证收到的 `zk 证明`的有效性。如果有效，合约会把新的 L2 退出根发送给`全局退出根管理器`，以更新全局退出树。

然后在桥接合约上调用 claimMessage 或 claimAsset，并附上正确验证退出叶子的默克尔证明。

桥接合约从 L1 `全局退出根管理器`检索全局退出根，并验证默克尔证明的有效性。如果默克尔证明有效，桥接完成。否则，交易被回滚。

### L2 to L2

当一批交易被处理时，桥合约会在L2退出树中添加一个包含该批交易信息的新叶子。这会更新L2退出树的根。

桥合约会把L2退出树的根传递给L2全局退出树管理器。不过，L2全局退出树管理器在这个阶段不会更新全局退出树。

为了进行证明和验证，`zk 证明`生成电路会从L2全局退出树管理器获取L2退出树的根。

只有在批次成功通过证明和验证后，L2全局退出树管理器才会将L2退出树的根添加到全局退出树中。这样，全局退出树的根就会更新。

`zk 证明`生成电路还会把L2退出树的根写入主网。然后，L1桥合约可以使用声明函数完成转账。