# overview

这部分文档详细分析了Polygon零知识系统架构的整体拓扑结构。

适用于CDK堆栈，采用zkEVM技术，这些文件探讨了组件系统和功能之间的内容、布局和交互。它们提供了对构成更大系统的组件的深入描述，同时参考了相关的代码库。

下面的图表展示了整个Polygon零知识系统架构的全面和详细的拓扑概述。

# components

## 1. Smart contracts: 

L1和L2的Solidity智能合约用来与整个堆栈进行交互。

## 2. Exit root trees:

Exit root trees 是一个仅追加的稀疏默克尔树，它记录了系统的当前和历史状态。

它被称为 "exit" 是因为它是用于将数据从 L2（Polygon zkEVM）转移到 L1（以太坊）的机制。当用户想要将资产从 L2 转移到 L1 时，他们需要提交一个退出请求，该请求将被记录在退出根树中。然后，证明者会生成一个证明，证明该请求已在 L2 上被正确处理，并将该证明发送到 L1。L1 上的智能合约会验证该证明，并最终将资产转移到用户的 L1 地址。

因此，"exit" 这个名字反映了退出根树在 L2 到 L1 的资产转移过程中的作用。

## 3. CDK && zkEVM

### 3.1 CDK解释

CDK 是 **C**onfigurable **D**eployment **K**it 的缩写，它是一个用于定义和部署云基础设施的框架。

在 Polygon zkEVM 的背景下，CDK 指的是一个用于构建和部署 zkEVM 节点的工具。它允许开发者使用代码来定义节点的配置，例如：

* 节点的类型（CDK 或 zkEVM）
* 节点运行的网络
* 节点的资源配置（例如 CPU、内存、存储）
* 节点的连接设置

CDK 使得部署和管理 zkEVM 节点变得更加容易，因为它提供了一种可重复且可扩展的方式来定义和部署节点。

### 3.2 为什么节点要分为CDK和zkEVM?他们有什么区别?

**CDK 节点(验证zk证明,无需运行合约代码或执行完整计算过程)** 是一种基于 CDK（可配置的开发者工具包）技术的节点，它主要用于验证和执行智能合约。CDK 节点使用了一种称为“有效性证明”的技术，可以快速验证智能合约的执行结果，而无需执行完整的计算过程。这些节点可以是验证者、观察者或其他角色，负责处理交易、维护网络状态等任务。

**zkEVM 节点(运行合约代码,生成zk证明)** 则使用 zkEVM（零知识以太坊虚拟机）技术，它可以执行完整的以太坊虚拟机代码，并生成零知识证明来验证执行结果。zkEVM 节点能够执行更复杂的智能合约，并提供更高的安全性。

**主要区别：**

* **执行能力：** CDK 节点只能执行经过验证的智能合约，而 zkEVM 节点可以执行任何以太坊虚拟机代码。
* **性能：** CDK 节点由于使用有效性证明，因此性能更高，可以更快地验证智能合约的执行结果。zkEVM 节点则需要进行完整的计算，因此性能相对较低。
* **安全性：** zkEVM 节点由于使用零知识证明，因此安全性更高，可以防止恶意攻击者篡改执行结果。

### 3.3 CDK 和 zkEVM 节点包含：

* 1. JSON RPC 客户端：公开用于与节点/链交互的读/写接口。
* 2. pool database：记录来自 JSON RPC 客户端的事务请求，并将其传递给排序器。它充当一个事务池，用于收集和管理待处理的事务。类似于以太坊的mempool.
* 2. state database：响应来自 JSON RPC 客户端的读取请求。它存储了系统当前的状态，并提供给用户查询。
* 3. Sequencer()：执行获取事务的复杂工作，并在将它们发送到聚合器进行批处理之前仔细排序它们。
* 4. Aggregator() ：聚合要发送给证明器的交易批处理。
* 5. Synchronizer ：通过 Etherman 组件和状态数据库确保节点系统与 L1 外部世界之间的状态同步。
* 6. Etherman ：通过智能合约功能与L1以太坊链通信，帮助Synchronizer保持与L1的同步状态。


### 3.3.0 Sequencer

负责将交易打包成批次并提交到共识合约。它会从交易池中收集交易，并将它们打包成批次，然后将这些批次添加到共识合约中。Sequencer会收取用户提交交易的费用，并支付L1交易费用和POL代币（取决于待处理的批次数量）。如果交易费用大于L1调用费用和POL费用，Sequencer就能盈利。


### 3.3.1 aggregator(generate zk proof)

负责验证交易批次并提供有效性证明。

Aggregator 的主要职责包括：

* 处理由 Sequencer 发布的交易信息。
* 构建 zkProof。
* 从 Sequencer 接收 POL 代币。
* 在去中心化的环境中，每个 Aggregator 需要声明其验证交易的意愿，并根据自己的策略竞争生成有效性证明。

Aggregator 的工作原理是：

1. 接收 Sequencer 提供的交易批次数据。
2. 使用 zkProver 生成零知识有效性证明。
3. 将有效性证明发送到智能合约进行验证。

Aggregator 的盈利方式是：

* 从 Sequencer 接收 POL 代币作为奖励。
* 支付 L1 调用成本和服务器成本（用于构建证明）。

Aggregator 的盈利条件是：POL 代币奖励大于 L1 调用成本和服务器成本。


### 3.3.2 Synchronizer

它负责将 Layer 1 (L1) 上的最新状态同步到 Layer 2 (L2)。

具体来说，Synchronizer 会：

* 监听 L1 上的 zkEVM 合约，获取最新的状态根（state root）。
* 将状态根同步到 L2 网络中的所有节点，包括 Sequencer 和 Aggregator。
* 确保 L2 网络中的所有节点都拥有最新的状态信息，从而保证 L2 网络的正常运行。

**Synchronizer 的作用是确保 L2 网络与 L1 网络保持一致**，并保证 L2 网络的安全性。

### 4. 统一网桥服务：

提供执行网桥声明的API，即L1/L2和L2/L2之间的资产和消息传输。

### 5. Prover：

用于计算交易批次的零知识证明的系统。


